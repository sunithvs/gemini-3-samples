<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sakura Pagoda 3D Experience</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 1.5rem; pointer-events: none;
            transition: opacity 0.5s;
            z-index: 10;
        }
        
        /* UI Overlay */
        .ui-container {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            pointer-events: none;
            z-index: 20;
        }

        .ui-card {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 1rem;
            color: rgba(255, 255, 255, 0.9);
            max-width: 350px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .ui-title {
            font-size: 1.8rem; font-weight: 300; margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 183, 197, 0.4);
            font-family: 'Cinzel', serif; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 0.5rem;
        }
        
        .ui-desc { font-size: 0.9rem; line-height: 1.5; color: #ccc; margin-bottom: 1rem; }
        
        /* Buttons */
        .btn-group { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            color: white;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .control-btn:hover {
            background: rgba(255, 183, 197, 0.2);
            border-color: #ffb7c5;
            transform: translateY(-1px);
        }
        .control-btn:active { transform: translateY(1px); }

        /* Chat/Response Area */
        #response-area {
            display: none;
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            font-style: italic;
            border-left: 3px solid #ffb7c5;
            animation: fadeIn 0.5s ease;
        }
        
        .response-controls {
            display: flex;
            justify-content: flex-end;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .input-group {
            display: none;
            margin-top: 1rem;
            gap: 0.5rem;
        }
        
        .chat-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            width: 100%;
            outline: none;
        }
        .chat-input:focus { border-color: #ffb7c5; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Loading Spinner for AI */
        .ai-loading {
            display: inline-block;
            width: 12px; height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #ffb7c5;
            animation: spin 1s ease-in-out infinite;
            margin-left: 5px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <div id="loading">Loading Zen Garden...</div>
    
    <div id="canvas-container"></div>

    <!-- <div class="ui-container">
        <div class="ui-card">
            <div class="ui-title">Sakura Sanctuary</div>
            <div class="ui-desc">
                A place of digital peace. Now inhabited by curious spirits.
            </div>
            
            <!-- <div class="btn-group">
                <button class="control-btn" onclick="togglePetals()">ðŸŒ¸ Toggle Wind</button>
                <button class="control-btn" onclick="generateHaiku()">âœ¨ Compose Haiku</button>
                <button class="control-btn" onclick="startMeditation()">ðŸ§˜ Guided Meditation</button>
                <button class="control-btn" onclick="toggleChat()">âœ¨ Seek Wisdom</button>
            </div> -->

            <!-- <!-- Chat Input -->
            <!-- <div id="input-group" class="input-group">
                <input type="text" id="user-query" class="chat-input" placeholder="Ask the Shrine Spirit..." onkeydown="if(event.key==='Enter') askSpirit()">
                <button class="control-btn" style="padding: 8px;" onclick="askSpirit()">â†’</button>
            </div> -->

            <!-- AI Response Display -->
            <!-- <div id="response-area">
                <p id="ai-text">The wind whispers through the trees...</p>
                <div class="response-controls" id="audio-controls" style="display:none;">
                    <button class="control-btn" id="play-audio-btn" style="font-size: 0.75rem;">ðŸ”Š Play Voice</button>
                </div>
            </div> -->
        <!-- </div> -->
    <!-- </div> --> --> -->

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- GEMINI API INTEGRATION ---
        const apiKey = ""; // Auto-filled by environment

        // --- TEXT GENERATION ---
        async function callGeminiText(prompt, systemInstruction = "") {
            if (!apiKey) { alert("API Key is missing!"); return null; }
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "The spirits are silent...";
            } catch (error) { console.error("Gemini API Error:", error); return "Connection error."; }
        }

        // --- TEXT TO SPEECH ---
        async function callGeminiTTS(text) {
            if (!apiKey) return null;
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Fenrir" } } } // Deep, calm voice
                }
            };
            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`HTTP TTS error! status: ${response.status}`);
                const data = await response.json();
                const base64Audio = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                return base64Audio; // PCM 16-bit
            } catch (error) { console.error("Gemini TTS Error:", error); return null; }
        }

        // --- AUDIO HELPERS (PCM to WAV) ---
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate = 24000) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.byteLength;
            const headerSize = 44;
            const totalSize = headerSize + dataSize;
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);

            // RIFF chunk
            writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(view, 8, 'WAVE');
            // fmt chunk
            writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitsPerSample, true);
            // data chunk
            writeString(view, 36, 'data'); view.setUint32(40, dataSize, true);

            const pcmBytes = new Uint8Array(pcmData);
            const wavBytes = new Uint8Array(buffer, 44);
            wavBytes.set(pcmBytes);
            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }

        let currentAudio = null;

        async function playAudio(base64PCM) {
            if (!base64PCM) return;
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            
            const pcmBuffer = base64ToArrayBuffer(base64PCM);
            const wavBlob = pcmToWav(pcmBuffer, 24000); // Default Gemini TTS rate
            const audioUrl = URL.createObjectURL(wavBlob);
            
            currentAudio = new Audio(audioUrl);
            currentAudio.play();
        }

        // --- FEATURE LOGIC ---

        function showResponseArea(text, audioBase64 = null) {
            const area = document.getElementById('response-area');
            const textEl = document.getElementById('ai-text');
            const audioCtrl = document.getElementById('audio-controls');
            const playBtn = document.getElementById('play-audio-btn');
            
            area.style.display = 'block';
            textEl.innerHTML = text.replace(/\n/g, '<br>');
            
            if (audioBase64) {
                audioCtrl.style.display = 'flex';
                playBtn.onclick = () => playAudio(audioBase64);
            } else {
                audioCtrl.style.display = 'none';
            }
        }

        function showLoading(msg = 'Consulting the spirits') {
            const area = document.getElementById('response-area');
            const textEl = document.getElementById('ai-text');
            document.getElementById('audio-controls').style.display = 'none';
            area.style.display = 'block';
            textEl.innerHTML = `${msg} <div class="ai-loading"></div>`;
        }

        async function generateHaiku() {
            showLoading("Composing poetry");
            const systemPrompt = "You are a poetic AI. Write a single haiku about cherry blossoms, pagodas, or nature. No title/analysis.";
            const text = await callGeminiText("Write a haiku.", systemPrompt);
            
            // Prefetch audio for seamless experience
            const audio = await callGeminiTTS(text);
            showResponseArea(text, audio);
        }

        async function startMeditation() {
            showLoading("Preparing meditation");
            const systemPrompt = "You are a meditation guide. Write a very short (2-3 sentences), soothing guided meditation script focusing on the cherry blossoms, the water reflection, and the stillness of this shrine. Do not include instructions like 'close your eyes', focus on the visual scene.";
            const text = await callGeminiText("Start the meditation.", systemPrompt);
            
            showResponseArea(text);
            // Generate and Auto-play for meditation
            const audio = await callGeminiTTS(text);
            if(audio) {
                showResponseArea(text, audio);
                playAudio(audio);
            }
        }

        let chatVisible = false;
        function toggleChat() {
            chatVisible = !chatVisible;
            document.getElementById('input-group').style.display = chatVisible ? 'flex' : 'none';
            if (chatVisible) document.getElementById('user-query').focus();
        }

        async function askSpirit() {
            const input = document.getElementById('user-query');
            const question = input.value.trim();
            if (!question) return;
            input.value = '';
            
            showLoading();
            const systemPrompt = "You are the ancient Kami (spirit) of this Sakura Shrine. Answer briefly and wisely. Be soothing.";
            const text = await callGeminiText(question, systemPrompt);
            
            const audio = await callGeminiTTS(text);
            showResponseArea(text, audio);
        }

        // --- 3D SCENE LOGIC ---
        
        const CONFIG = {
            colors: {
                skyTop: 0x87CEEB, skyBottom: 0xFFC0CB, fog: 0xffdbe6, water: 0x4a6b8a,
                woodDark: 0x3d2817, woodRed: 0x8a3324, roof: 0x2c3e50, sakura: 0xffb7c5, sakuraDark: 0xffa7b5,
                alienBody: 0x98fb98, alienEye: 0x000000
            },
            particles: 3000
        };

        let scene, camera, renderer, controls, particleSystem, clock = new THREE.Clock();
        let windSpeed = 1.0;
        let aliens = []; 
        let doors = []; // Store door objects { left, right, requests, position, isOpen }
        
        // Obstacles for collision detection (x, z, radius)
        const obstacles = [
            { x: 0, z: 0, r: 2.0 }, // REDUCED from 6.5 to 2.0 to allow walking on platform
            { x: 12, z: 5, r: 3.5 }, 
            { x: -12, z: 5, r: 3.5 }, 
            { x: 12, z: -5, r: 3.5 }, 
            { x: -12, z: -5, r: 3.5 } 
        ];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015);
            scene.background = new THREE.Color(CONFIG.colors.fog);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 12, 35);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 80;
            controls.target.set(0, 5, 0);

            setupLighting();
            createWater();
            createPagoda(); // Creates doors now
            createSubHouses();
            createEnvironment();
            createSakuraParticles();
            createAliens();

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('loading').style.opacity = 0;
            animate();
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffe6ea, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 30, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -40;
            dirLight.shadow.camera.right = 40;
            dirLight.shadow.camera.top = 40;
            dirLight.shadow.camera.bottom = -40;
            scene.add(dirLight);
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0xFFC0CB, 0.4);
            scene.add(hemiLight);
        }

        function createCurvedRoofGeo(width, height, segments = 4) {
            const points = [];
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                points.push(new THREE.Vector2(width * t, height * (1 - Math.pow(t, 2))));
            }
            return new THREE.LatheGeometry(points, segments);
        }

        function createPagoda() {
            const pagodaGroup = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodRed, roughness: 0.8 });
            const darkWoodMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodDark, roughness: 0.9 });
            const roofMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.roof, roughness: 0.6, flatShading: true, side: THREE.DoubleSide });
            const whiteWallMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const base = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 12), new THREE.MeshStandardMaterial({ color: 0x555555 }));
            base.position.y = 0; base.receiveShadow = true; pagodaGroup.add(base);

            let currentY = 2; let width = 7;
            for (let i = 0; i < 3; i++) {
                const wallHeight = 3.5;
                const wallWidth = width * 0.7;
                
                // Create Main Wall with holes for doors on bottom floor
                if (i === 0) {
                     // We build the bottom floor walls manually to leave gaps for doors
                    // Left/Right Walls (Solid)
                    const sideWallGeo = new THREE.BoxGeometry(wallWidth, wallHeight, 0.2);
                    const w1 = new THREE.Mesh(sideWallGeo, whiteWallMat); w1.position.set(0, currentY+wallHeight/2, wallWidth/2);
                    const w2 = new THREE.Mesh(sideWallGeo, whiteWallMat); w2.position.set(0, currentY+wallHeight/2, -wallWidth/2);
                    pagodaGroup.add(w1); pagodaGroup.add(w2);

                    // Front/Back Walls (With Door Gaps)
                    // Side pieces
                    const gapSize = 2.0;
                    const pieceWidth = (wallWidth - gapSize) / 2;
                    const frontGeo = new THREE.BoxGeometry(0.2, wallHeight, pieceWidth);
                    
                    // Front Side Pieces
                    const f1 = new THREE.Mesh(frontGeo, whiteWallMat); f1.position.set(wallWidth/2, currentY+wallHeight/2, pieceWidth/2 + gapSize/2);
                    const f2 = new THREE.Mesh(frontGeo, whiteWallMat); f2.position.set(wallWidth/2, currentY+wallHeight/2, -(pieceWidth/2 + gapSize/2));
                    // Back Side Pieces
                    const b1 = new THREE.Mesh(frontGeo, whiteWallMat); b1.position.set(-wallWidth/2, currentY+wallHeight/2, pieceWidth/2 + gapSize/2);
                    const b2 = new THREE.Mesh(frontGeo, whiteWallMat); b2.position.set(-wallWidth/2, currentY+wallHeight/2, -(pieceWidth/2 + gapSize/2));
                    
                    pagodaGroup.add(f1); pagodaGroup.add(f2); pagodaGroup.add(b1); pagodaGroup.add(b2);
                    
                    // Top Lintel (above door)
                    const lintelGeo = new THREE.BoxGeometry(0.2, 1.0, gapSize);
                    const fl = new THREE.Mesh(lintelGeo, whiteWallMat); fl.position.set(wallWidth/2, currentY+wallHeight - 0.5, 0);
                    const bl = new THREE.Mesh(lintelGeo, whiteWallMat); bl.position.set(-wallWidth/2, currentY+wallHeight - 0.5, 0);
                    pagodaGroup.add(fl); pagodaGroup.add(bl);

                    // --- CREATE DOORS ---
                    createDoor(pagodaGroup, wallWidth/2, currentY, 0, 0); // Front Door (rot 0)
                    createDoor(pagodaGroup, -wallWidth/2, currentY, 0, Math.PI); // Back Door (rot 180)

                } else {
                    // Upper floors are simple boxes
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(wallWidth, wallHeight, wallWidth), whiteWallMat);
                    wall.position.y = currentY + wallHeight / 2; wall.castShadow = true; wall.receiveShadow = true; pagodaGroup.add(wall);
                }

                const pillarGeo = new THREE.BoxGeometry(0.4, wallHeight, 0.4);
                const wOffset = (width * 0.7) / 2 + 0.1;
                [{x: 1, z: 1}, {x: -1, z: 1}, {x: 1, z: -1}, {x: -1, z: -1}].forEach(pos => {
                    const pillar = new THREE.Mesh(pillarGeo, woodMat);
                    pillar.position.set(pos.x * wOffset, currentY + wallHeight/2, pos.z * wOffset); pagodaGroup.add(pillar);
                });

                const roofHeight = 2.5; const roofWidth = width + 2.5;
                const roof = new THREE.Mesh(createCurvedRoofGeo(roofWidth * 0.7, roofHeight, 4), roofMat);
                roof.rotation.y = Math.PI / 4; roof.position.y = currentY + wallHeight; roof.castShadow = true; pagodaGroup.add(roof);

                if (i < 3) {
                    const rail = new THREE.Mesh(new THREE.BoxGeometry(width, 0.2, width), darkWoodMat);
                    rail.position.y = currentY; pagodaGroup.add(rail);
                }
                currentY += wallHeight + roofHeight - 1.2; width *= 0.75;
            }
            
            const spire = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 5, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            spire.position.y = currentY + 1.5; pagodaGroup.add(spire);
            scene.add(pagodaGroup);
        }

        // New Helper to create a detailed Sliding Door
        function createDoor(parentGroup, x, y, z, rotationY) {
            const doorH = 2.5;
            const doorW = 0.9; // Each panel
            const doorThick = 0.1;

            const doorMat = new THREE.MeshStandardMaterial({ color: 0xDba279, roughness: 0.7 }); // Paper/Wood color
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodDark });

            const doorGroup = new THREE.Group();
            doorGroup.position.set(x, y + doorH/2, z);
            doorGroup.rotation.y = rotationY;

            // Create Panels (Shoji style)
            const createPanel = (offsetX) => {
                const panel = new THREE.Group();
                // Frame
                const frame = new THREE.Mesh(new THREE.BoxGeometry(doorThick, doorH, doorW), frameMat);
                // Paper inset
                const paper = new THREE.Mesh(new THREE.BoxGeometry(doorThick/2, doorH-0.2, doorW-0.2), doorMat);
                panel.add(frame);
                panel.add(paper);
                panel.position.z = offsetX;
                return panel;
            };

            const leftPanel = createPanel(doorW/2);
            const rightPanel = createPanel(-doorW/2);

            doorGroup.add(leftPanel);
            doorGroup.add(rightPanel);
            parentGroup.add(doorGroup);

            // Register door for logic
            // Position for aliens to walk to: Just outside the door
            // Entrance Vector (Offset slightly outside)
            const facingDir = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), rotationY);
            
            // UPDATED: Calculate positions relative to the PLATFORM HEIGHT (y=2)
            // Outside pos: x, 2, z + offset. Inside pos: x, 2, z - offset.
            const platformY = 2.0;
            const outsidePos = new THREE.Vector3(x, platformY, z).add(facingDir.clone().multiplyScalar(0.7)); 
            const insidePos = new THREE.Vector3(x, platformY, z).add(facingDir.clone().multiplyScalar(-0.7)); 

            doors.push({
                id: doors.length,
                group: doorGroup,
                left: leftPanel,
                right: rightPanel,
                outsidePos: outsidePos,
                insidePos: insidePos,
                requests: 0, // How many aliens want this open
                state: 0, // 0 closed, 1 opening, 2 open, 3 closing
                openFactor: 0 // 0 to 1
            });
        }

        function createSubHouses() {
            const createHouse = (x, z, rotation) => {
                const house = new THREE.Group();
                house.add(new THREE.Mesh(new THREE.BoxGeometry(5, 1, 5), new THREE.MeshStandardMaterial({ color: 0x555555 })));
                const walls = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                walls.position.y = 2; walls.castShadow = true; house.add(walls);
                
                const roof = new THREE.Mesh(createCurvedRoofGeo(3.5, 2.5, 4), new THREE.MeshStandardMaterial({ color: CONFIG.colors.roof, side: THREE.DoubleSide }));
                roof.rotation.y = Math.PI / 4; roof.position.y = 3.5; roof.castShadow = true; house.add(roof);

                house.position.set(x, 1, z); house.rotation.y = rotation; scene.add(house);
            };
            createHouse(12, 5, -Math.PI / 4); createHouse(-12, 5, Math.PI / 4);
            createHouse(12, -5, -Math.PI * 0.75); createHouse(-12, -5, Math.PI * 0.75);
        }

        function createWater() {
            const waterMesh = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({
                color: 0x5E84A1, roughness: 0.1, metalness: 0.5, transparent: true, opacity: 0.8
            }));
            waterMesh.rotation.x = -Math.PI / 2; waterMesh.receiveShadow = true; scene.add(waterMesh);
        }

        function createEnvironment() {
            const trunkMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodDark });
            const leavesMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.sakura, flatShading: true });
            const leavesMatDark = new THREE.MeshStandardMaterial({ color: CONFIG.colors.sakuraDark, flatShading: true });

            const treeGen = () => {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5, 7), trunkMat);
                trunk.position.y = 2.5; tree.add(trunk);

                for(let i=0; i<4; i++) {
                    const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.25, 4, 5), trunkMat);
                    branch.position.y = 4.5; branch.rotation.z = Math.PI / 3; 
                    branch.rotation.y = (Math.PI * 2 / 4) * i; branch.translateY(1.5); tree.add(branch);

                    for(let j=0; j<3; j++) {
                        const leaf = new THREE.Mesh(new THREE.DodecahedronGeometry(1 + Math.random(), 0), Math.random()>0.5?leavesMat:leavesMatDark);
                        leaf.position.copy(branch.position); 
                        leaf.position.x += (Math.random()-0.5)*3; leaf.position.y += (Math.random()-0.5)*3; leaf.position.z += (Math.random()-0.5)*3;
                        tree.add(leaf);
                    }
                }
                return tree;
            };

            for (let i = 0; i < 25; i++) {
                const tree = treeGen();
                const angle = (i / 25) * Math.PI * 2; const radius = 20 + Math.random() * 15;
                tree.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                tree.scale.setScalar(0.9 + Math.random() * 0.4); scene.add(tree);
            }
        }

        function createSakuraParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [], velocities = [];
            
            // Create Texture
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffb7c5'; ctx.beginPath(); ctx.ellipse(16, 16, 8, 14, Math.PI/4, 0, Math.PI * 2); ctx.fill();

            for (let i = 0; i < CONFIG.particles; i++) {
                positions.push((Math.random()-0.5)*80, Math.random()*50, (Math.random()-0.5)*80);
                velocities.push((Math.random()-0.5)*0.05, -0.02 - Math.random()*0.05, (Math.random()-0.5)*0.05);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            particleSystem = new THREE.Points(geometry, new THREE.PointsMaterial({
                color: CONFIG.colors.sakura, size: 0.4, map: new THREE.CanvasTexture(canvas),
                transparent: true, opacity: 0.8, depthWrite: false, blending: THREE.AdditiveBlending
            }));
            scene.add(particleSystem);
        }

        // --- ALIEN LOGIC ---
        function createAliens() {
            const bodyMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.alienBody, emissive: 0x335533, roughness: 0.4 });
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 });

            for(let i=0; i<15; i++) {
                const alien = new THREE.Group();
                
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), bodyMat);
                body.scale.set(1, 2.5, 1); 
                body.position.y = 0.6;
                alien.add(body);

                const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 12), bodyMat);
                head.position.y = 1.0;
                alien.add(head);

                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeMat);
                leftEye.position.set(0.15, 1.05, 0.25);
                alien.add(leftEye);

                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), eyeMat);
                rightEye.position.set(-0.15, 1.05, 0.25);
                alien.add(rightEye);

                // Spawn in forest area
                const angle = Math.random() * Math.PI * 2;
                const dist = 25 + Math.random() * 20;
                alien.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);

                scene.add(alien);

                aliens.push({
                    mesh: alien,
                    state: 'WANDERING', // WANDERING, SEEKING_HOME, WAITING_ENTRY, ENTERING, INSIDE, WAITING_EXIT, EXITING, DESCENDING
                    target: new THREE.Vector3(),
                    targetDoorId: -1,
                    speed: 0.08 + Math.random() * 0.04,
                    timer: 0,
                    runOffset: Math.random() * 100,
                    
                    // Life Cycle Props
                    maxLife: 60, // 60 seconds life cycle
                    currentLife: 30 + Math.random() * 30, // Staggered start
                });
            }
        }

        // Helper for 2D distance (ignoring Y for triggers)
        function dist2D(v1, v2) {
            const dx = v1.x - v2.x;
            const dz = v1.z - v2.z;
            return Math.sqrt(dx*dx + dz*dz);
        }

        function updateAliensAndDoors() {
            const dt = 0.016; // Approximate delta time (60fps)

            // 1. Update Doors
            doors.forEach(door => {
                const target = door.requests > 0 ? 1 : 0;
                door.openFactor += (target - door.openFactor) * 0.1;
                const slideDist = 0.8 * door.openFactor;
                door.left.position.z = 0.45 + slideDist;
                door.right.position.z = -0.45 - slideDist;
            });

            // 2. Update Aliens
            aliens.forEach(a => {
                const pos = a.mesh.position;
                const time = clock.getElapsedTime() + a.runOffset;

                // Decrease life
                if (a.state !== 'INSIDE' && a.state !== 'ENTERING' && a.state !== 'WAITING_ENTRY') {
                    a.currentLife -= dt;
                }

                // --- STATE MACHINE ---

                if (a.state === 'WANDERING') {
                    // Check Battery
                    if (a.currentLife < 20) { // Low battery trigger
                        a.state = 'SEEKING_HOME';
                        // Find closest door
                        let minDist = Infinity;
                        let closestDoorId = 0;
                        doors.forEach(d => {
                            const dDist = dist2D(pos, d.outsidePos);
                            if (dDist < minDist) {
                                minDist = dDist;
                                closestDoorId = d.id;
                            }
                        });
                        a.targetDoorId = closestDoorId;
                        a.target.copy(doors[closestDoorId].outsidePos);
                    }
                    else {
                        // Normal Wandering Logic
                        if (dist2D(pos, a.target) < 1 || a.target.lengthSq() === 0) {
                             // Pick new random target
                             const angle = Math.random() * Math.PI * 2;
                             const dist = 20 + Math.random() * 25;
                             a.target.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
                        }
                        steerAlien(a, time, 0); // Wandering at y=0
                    }
                }
                else if (a.state === 'SEEKING_HOME') {
                    // Use Steering to navigate to door
                    if (dist2D(pos, a.target) < 0.3) {
                        a.state = 'WAITING_ENTRY';
                        const door = doors[a.targetDoorId];
                        door.requests++;
                    } else {
                        // Fly up logic for platform
                        // If close to center, fly up
                        const distToCenter = Math.sqrt(pos.x*pos.x + pos.z*pos.z);
                        let targetHeight = 0;
                        if(distToCenter < 10) targetHeight = 2.0;
                        
                        steerAlien(a, time, targetHeight);
                    }
                }
                else if (a.state === 'WAITING_ENTRY') {
                    const door = doors[a.targetDoorId];
                    if (door.openFactor > 0.8) {
                        a.state = 'ENTERING';
                        a.target.copy(door.insidePos);
                    }
                }
                else if (a.state === 'ENTERING') {
                    if (dist2D(pos, a.target) < 0.2) {
                        a.state = 'INSIDE';
                        // RECHARGE!
                        a.currentLife = a.maxLife; 
                        
                        a.timer = 200; // Short recharge wait
                        a.mesh.visible = false;
                        const door = doors[a.targetDoorId];
                        door.requests--;
                    } else {
                        steerAlien(a, time, 2.0);
                    }
                }
                else if (a.state === 'INSIDE') {
                    a.timer--;
                    if (a.timer <= 0) {
                        a.mesh.visible = true;
                        a.state = 'WAITING_EXIT';
                        const door = doors[a.targetDoorId];
                        door.requests++;
                        a.target.copy(door.outsidePos);
                        a.mesh.position.copy(door.insidePos);
                    }
                }
                else if (a.state === 'WAITING_EXIT') {
                    const door = doors[a.targetDoorId];
                    if (door.openFactor > 0.8) {
                        a.state = 'EXITING';
                    }
                }
                else if (a.state === 'EXITING') {
                    if (dist2D(pos, a.target) < 0.5) {
                        // Switch to DESCENDING phase instead of WANDERING directly
                        a.state = 'DESCENDING';
                        const door = doors[a.targetDoorId];
                        door.requests--; // Close door behind us
                        
                        // Set target far away from door to force walking off platform edge
                        const exitDir = new THREE.Vector3().subVectors(door.outsidePos, door.insidePos).normalize();
                        a.target.copy(door.outsidePos).add(exitDir.multiplyScalar(10)); 
                    } else {
                        steerAlien(a, time, 2.0); // Stay on platform height
                    }
                }
                else if (a.state === 'DESCENDING') {
                    // Check if still on platform (Box radius approx 6.0, using 6.5 to be safe)
                    const onPlatform = Math.max(Math.abs(pos.x), Math.abs(pos.z)) < 6.5;
                    
                    if (onPlatform) {
                        steerAlien(a, time, 2.0); // Walk to edge
                    } else {
                        steerAlien(a, time, 0.0); // Fly down to grass
                    }

                    // Once reached ground target or close enough, switch to wander
                    if (dist2D(pos, a.target) < 1.0 || (pos.y < 0.2 && !onPlatform)) {
                        a.state = 'WANDERING';
                        // Pick new random wander target
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 20 + Math.random() * 25;
                        a.target.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
                    }
                }
            });
        }

        // Advanced Steering Behavior: Seek + Avoid
        function steerAlien(a, time, targetHeight) {
            const pos = a.mesh.position;
            
            // 1. Seek Force (Towards Target)
            const desired = new THREE.Vector3().subVectors(a.target, pos);
            desired.y = 0; // Process 2D plane for steering
            desired.normalize().multiplyScalar(a.speed);

            // 2. Avoidance Force (Obstacles)
            const avoidance = new THREE.Vector3(0,0,0);
            const avoidRadius = 2.0; // How early to start avoiding
            
            // NEW: Disable avoidance if we are very close to our target (final docking)
            const distToTarget = dist2D(pos, a.target);
            if (distToTarget > 1.0) { 
                for(let obs of obstacles) {
                    const obsPos = new THREE.Vector3(obs.x, 0, obs.z);
                    const dist = dist2D(pos, obsPos);
                    
                    // If inside obstacle influence zone
                    if (dist < obs.r + avoidRadius) {
                         // Calculate vector away from obstacle
                         const push = new THREE.Vector3().subVectors(pos, obsPos);
                         push.y = 0;
                         // The closer we are, the stronger the push
                         const strength = (obs.r + avoidRadius - dist) / (obs.r + avoidRadius);
                         push.normalize().multiplyScalar(strength * 0.2); // 0.2 is max avoidance force
                         avoidance.add(push);
                    }
                }
            }

            // 3. Combine Forces
            // Velocity = Desired + Avoidance
            const velocity = desired.add(avoidance);
            
            // If avoidance is strong, it might push us weirdly, normalize speed again
            if (velocity.length() > a.speed) velocity.normalize().multiplyScalar(a.speed);

            // Apply Movement
            pos.x += velocity.x;
            pos.z += velocity.z;

            // Smooth Y Movement
            const bob = Math.abs(Math.sin(time * 15)) * 0.2;
            pos.y += (targetHeight - pos.y) * 0.05; // Smooth lerp to target height
            
            // Look At (using next projected point)
            const lookTarget = new THREE.Vector3(pos.x + velocity.x * 10, pos.y, pos.z + velocity.z * 10);
            a.mesh.lookAt(lookTarget);
            
            // Apply bob visually after lookAt to not jitter rotation
            a.mesh.position.y += bob * 0.1; 
        }

        function togglePetals() { windSpeed = windSpeed === 1.0 ? 5.0 : 1.0; }
        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate); controls.update();
            updateAliensAndDoors(); // NEW: Update logic
            
            if (particleSystem) {
                const pos = particleSystem.geometry.attributes.position.array;
                const vel = particleSystem.geometry.attributes.velocity.array;
                const time = clock.getElapsedTime();
                for (let i = 0; i < CONFIG.particles; i++) {
                    const i3 = i * 3;
                    pos[i3] += vel[i3] * windSpeed + Math.sin(time * 0.5 + pos[i3 + 1]) * 0.002 * windSpeed;
                    pos[i3 + 1] += vel[i3 + 1];
                    pos[i3 + 2] += vel[i3 + 2] * windSpeed;
                    if (pos[i3 + 1] < 0) { pos[i3 + 1] = 40 + Math.random() * 10; pos[i3] = (Math.random()-0.5)*80; pos[i3+2] = (Math.random()-0.5)*80; }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
