<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sakura Pagoda 3D Experience</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-size: 1.5rem; pointer-events: none;
            transition: opacity 0.5s;
            z-index: 10;
        }
        
        /* UI Overlay */
        .ui-container {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            pointer-events: none;
            z-index: 20;
        }

        .ui-card {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 1rem;
            color: rgba(255, 255, 255, 0.9);
            max-width: 350px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .ui-title {
            font-size: 1.8rem; font-weight: 300; margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 183, 197, 0.4);
            font-family: 'Cinzel', serif; 
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 0.5rem;
        }
        
        .ui-desc { font-size: 0.9rem; line-height: 1.5; color: #ccc; margin-bottom: 1rem; }
        
        /* Buttons */
        .btn-group { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            color: white;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .control-btn:hover {
            background: rgba(255, 183, 197, 0.2);
            border-color: #ffb7c5;
            transform: translateY(-1px);
        }
        .control-btn:active { transform: translateY(1px); }

        /* Chat/Response Area */
        #response-area {
            display: none;
            margin-top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            font-style: italic;
            border-left: 3px solid #ffb7c5;
            animation: fadeIn 0.5s ease;
        }
        
        .input-group {
            display: none;
            margin-top: 1rem;
            gap: 0.5rem;
        }
        
        .chat-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            width: 100%;
            outline: none;
        }
        .chat-input:focus { border-color: #ffb7c5; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Loading Spinner for AI */
        .ai-loading {
            display: inline-block;
            width: 12px; height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #ffb7c5;
            animation: spin 1s ease-in-out infinite;
            margin-left: 5px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>

    <div id="loading">Loading Zen Garden...</div>
    
    <div id="canvas-container"></div>

    <div class="ui-container">
        <div class="ui-card">
            <div class="ui-title">Sakura Sanctuary</div>
            <div class="ui-desc">
                A place of digital peace.
            </div>
            
            <div class="btn-group">
                <button class="control-btn" onclick="togglePetals()">ðŸŒ¸ Toggle Wind</button>
                <button class="control-btn" onclick="generateHaiku()">âœ¨ Compose Haiku</button>
                <button class="control-btn" onclick="toggleChat()">âœ¨ Seek Wisdom</button>
            </div>

            <!-- Chat Input -->
            <div id="input-group" class="input-group">
                <input type="text" id="user-query" class="chat-input" placeholder="Ask the Shrine Spirit..." onkeydown="if(event.key==='Enter') askSpirit()">
                <button class="control-btn" style="padding: 8px;" onclick="askSpirit()">â†’</button>
            </div>

            <!-- AI Response Display -->
            <div id="response-area">
                <p id="ai-text">The wind whispers through the trees...</p>
            </div>
        </div>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- GEMINI API INTEGRATION ---
        const apiKey = ""; // Auto-filled by environment

        async function callGemini(prompt, systemInstruction = "") {
            if (!apiKey) {
                alert("API Key is missing!");
                return null;
            }

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "The spirits are silent...";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return "The connection to the spirit realm is weak (Error).";
            }
        }

        // --- AI Features UI Logic ---

        function showResponseArea(text) {
            const area = document.getElementById('response-area');
            const textEl = document.getElementById('ai-text');
            area.style.display = 'block';
            textEl.innerHTML = text.replace(/\n/g, '<br>');
        }

        function showLoading() {
            const area = document.getElementById('response-area');
            const textEl = document.getElementById('ai-text');
            area.style.display = 'block';
            textEl.innerHTML = 'Consulting the spirits <div class="ai-loading"></div>';
        }

        async function generateHaiku() {
            showLoading();
            const systemPrompt = "You are a poetic AI. Write a single haiku about cherry blossoms, pagodas, water, or nature. Do not include a title or analysis. Just the three lines.";
            const text = await callGemini("Write a haiku for this moment.", systemPrompt);
            showResponseArea(text);
        }

        let chatVisible = false;
        function toggleChat() {
            chatVisible = !chatVisible;
            const inputGroup = document.getElementById('input-group');
            inputGroup.style.display = chatVisible ? 'flex' : 'none';
            if (chatVisible) document.getElementById('user-query').focus();
        }

        async function askSpirit() {
            const input = document.getElementById('user-query');
            const question = input.value.trim();
            if (!question) return;

            input.value = '';
            showLoading();
            
            const systemPrompt = "You are the ancient, wise Kami (spirit) of this Sakura Shrine. Answer the user's philosophical questions with profound, peaceful, and slightly archaic/poetic wisdom. Keep responses relatively short (under 3 sentences). Be soothing.";
            const text = await callGemini(question, systemPrompt);
            showResponseArea(text);
        }


        // --- 3D SCENE LOGIC (Existing) ---

        // Configuration
        const CONFIG = {
            colors: {
                skyTop: 0x87CEEB,
                skyBottom: 0xFFC0CB,
                fog: 0xffdbe6, // Pinkish fog
                water: 0x4a6b8a,
                woodDark: 0x3d2817,
                woodRed: 0x8a3324,
                roof: 0x2c3e50, // Dark blue/grey
                roofHighlight: 0x4a6b8a,
                sakura: 0xffb7c5,
                sakuraDark: 0xffa7b5
            },
            particles: 3000
        };

        let scene, camera, renderer, controls;
        let particles, particleSystem;
        let waterMesh;
        let clock = new THREE.Clock();
        let windSpeed = 1.0;

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            
            // Fog for atmospheric depth (Soft pink/white)
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015);
            scene.background = new THREE.Color(CONFIG.colors.fog);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 12, 35);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Don't go below ground
            controls.minDistance = 5;
            controls.maxDistance = 80;
            controls.target.set(0, 5, 0);

            // 5. Lighting
            setupLighting();

            // 6. Objects
            createWater();
            createPagoda();
            createSubHouses();
            createEnvironment();
            createSakuraParticles();

            // 7. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            // Remove loading text
            document.getElementById('loading').style.opacity = 0;
            
            animate();
        }

        function setupLighting() {
            // Soft ambient light
            const ambientLight = new THREE.AmbientLight(0xffe6ea, 0.6);
            scene.add(ambientLight);

            // Sun light
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 30, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -40;
            dirLight.shadow.camera.right = 40;
            dirLight.shadow.camera.top = 40;
            dirLight.shadow.camera.bottom = -40;
            scene.add(dirLight);

            // Rim light for the anime aesthetic
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0xFFC0CB, 0.4);
            scene.add(hemiLight);
        }

        // --- Helper: Curved Roof Geometry ---
        function createCurvedRoofGeo(width, height, segments = 4) {
            const points = [];
            // Create a swooping curve profile
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const x = width * t;
                // Exponential curve for the Japanese roof style
                const y = height * (1 - Math.pow(t, 2)); 
                points.push(new THREE.Vector2(x, y));
            }
            // Use LatheGeometry to spin this curve
            const geometry = new THREE.LatheGeometry(points, segments);
            return geometry;
        }

        // --- Procedural Object Creation ---

        function createPagoda() {
            const pagodaGroup = new THREE.Group();

            // Materials
            const woodMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodRed, roughness: 0.8 });
            const darkWoodMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodDark, roughness: 0.9 });
            const roofMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.roof, 
                roughness: 0.6,
                flatShading: true,
                side: THREE.DoubleSide
            });
            const whiteWallMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            // Base Platform
            const baseGeo = new THREE.BoxGeometry(12, 4, 12);
            const base = new THREE.Mesh(baseGeo, new THREE.MeshStandardMaterial({ color: 0x555555 }));
            base.position.y = 0;
            base.receiveShadow = true;
            pagodaGroup.add(base);

            // Tiers
            const tiers = 3;
            let currentY = 2;
            let width = 7;

            for (let i = 0; i < tiers; i++) {
                // 1. Wall Core
                const wallHeight = 3.5;
                const wallGeo = new THREE.BoxGeometry(width * 0.7, wallHeight, width * 0.7);
                const wall = new THREE.Mesh(wallGeo, whiteWallMat);
                wall.position.y = currentY + wallHeight / 2;
                wall.castShadow = true;
                wall.receiveShadow = true;
                pagodaGroup.add(wall);

                // 2. Pillars (Corners)
                const pillarGeo = new THREE.BoxGeometry(0.4, wallHeight, 0.4);
                const positions = [
                    {x: 1, z: 1}, {x: -1, z: 1}, {x: 1, z: -1}, {x: -1, z: -1}
                ];
                const wOffset = (width * 0.7) / 2 + 0.1;
                
                positions.forEach(pos => {
                    const pillar = new THREE.Mesh(pillarGeo, woodMat);
                    pillar.position.set(pos.x * wOffset, currentY + wallHeight/2, pos.z * wOffset);
                    pagodaGroup.add(pillar);
                });

                // 3. Curved Roof
                const roofHeight = 2.5;
                const roofWidth = width + 2.5; // Overhang
                
                // Use LatheGeometry for curve
                const roofGeo = createCurvedRoofGeo(roofWidth * 0.7, roofHeight, 4);
                const roof = new THREE.Mesh(roofGeo, roofMat);
                
                // Lathe creates round, we need square for pagoda but with curved slope
                // Standard Lathe is round. To make it square-ish with 4 segments:
                // We already set segments=4 in helper. Now rotate to align corners.
                roof.rotation.y = Math.PI / 4; 
                roof.position.y = currentY + wallHeight;
                roof.castShadow = true;
                pagodaGroup.add(roof);

                // Roof Spire/Finial on top of roof if needed, but mainly the main spire
                
                // Balcony Railing for non-top floors
                if (i < tiers) {
                    const railGeo = new THREE.BoxGeometry(width, 0.2, width);
                    const rail = new THREE.Mesh(railGeo, darkWoodMat);
                    rail.position.y = currentY;
                    pagodaGroup.add(rail);
                }

                // Update height for next tier
                currentY += wallHeight + roofHeight - 1.2; // overlap
                width *= 0.75; // Taper
            }

            // Spire (Sorin)
            const spireHeight = 5;
            const spireGeo = new THREE.CylinderGeometry(0.1, 0.3, spireHeight, 8);
            const spire = new THREE.Mesh(spireGeo, new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 }));
            spire.position.y = currentY + spireHeight/2 - 1;
            pagodaGroup.add(spire);

            // Rings on spire
            for(let j=0; j<5; j++) {
                const ringGeo = new THREE.TorusGeometry(0.4 - (j*0.05), 0.05, 8, 16);
                const ring = new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({ color: 0xD4AF37 })); // Gold
                ring.rotation.x = Math.PI/2;
                ring.position.y = currentY + 0.5 + (j * 0.6);
                pagodaGroup.add(ring);
            }

            scene.add(pagodaGroup);
        }

        function createSubHouses() {
            const createHouse = (x, z, rotation) => {
                const house = new THREE.Group();
                
                // Base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 1, 5),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                house.add(base);

                // Walls
                const walls = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 3, 4),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                walls.position.y = 2;
                walls.castShadow = true;
                house.add(walls);

                // Wood pillars
                const pGeo = new THREE.BoxGeometry(0.3, 3, 0.3);
                const pMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodRed });
                const positions = [{x:1.9, z:1.9}, {x:-1.9, z:1.9}, {x:1.9, z:-1.9}, {x:-1.9, z:-1.9}];
                positions.forEach(p => {
                    const m = new THREE.Mesh(pGeo, pMat);
                    m.position.set(p.x, 2, p.z);
                    house.add(m);
                });

                // Curved Roof
                const roofGeo = createCurvedRoofGeo(3.5, 2.5, 4);
                const roof = new THREE.Mesh(
                    roofGeo, 
                    new THREE.MeshStandardMaterial({ color: CONFIG.colors.roof, side: THREE.DoubleSide, roughness: 0.6 })
                );
                roof.rotation.y = Math.PI / 4;
                roof.position.y = 3.5;
                roof.castShadow = true;
                house.add(roof);

                house.position.set(x, 1, z);
                house.rotation.y = rotation;
                scene.add(house);
            };

            // Place sub-houses symmetrically
            createHouse(12, 5, -Math.PI / 4);
            createHouse(-12, 5, Math.PI / 4);
            createHouse(12, -5, -Math.PI * 0.75);
            createHouse(-12, -5, Math.PI * 0.75);
        }

        function createWater() {
            const waterGeometry = new THREE.PlaneGeometry(200, 200);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x5E84A1,
                roughness: 0.1,
                metalness: 0.5,
                transparent: true,
                opacity: 0.8
            });

            waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.position.y = 0;
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);
        }

        function createEnvironment() {
            // Improved Realistic Tree Generator
            const trunkMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.woodDark, roughness: 1.0 });
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.sakura, 
                flatShading: true 
            });
            const leavesMatDark = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.sakuraDark, 
                flatShading: true 
            });

            const treeGen = () => {
                const tree = new THREE.Group();
                
                // 1. Main Trunk (slightly twisted)
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 5, 7);
                // Displace vertices slightly for organic look
                const posAttribute = trunkGeo.attributes.position;
                for (let i = 0; i < posAttribute.count; i++) {
                    const y = posAttribute.getY(i);
                    if(y > 0) {
                        posAttribute.setX(i, posAttribute.getX(i) + (Math.random()-0.5)*0.3);
                        posAttribute.setZ(i, posAttribute.getZ(i) + (Math.random()-0.5)*0.3);
                    }
                }
                trunkGeo.computeVertexNormals();
                
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 2.5;
                tree.add(trunk);

                // 2. Branches
                const branchCount = 4;
                for(let i=0; i<branchCount; i++) {
                    const branchLength = 3 + Math.random() * 2;
                    const branchGeo = new THREE.CylinderGeometry(0.1, 0.25, branchLength, 5);
                    const branch = new THREE.Mesh(branchGeo, trunkMat);
                    
                    // Position at top of trunk
                    branch.position.y = 4 + (Math.random() * 1);
                    branch.rotation.z = (Math.PI / 3) + (Math.random() * 0.5); // Angle out
                    branch.rotation.y = (Math.PI * 2 / branchCount) * i + (Math.random() * 0.5);
                    
                    // Move branch out so it connects
                    branch.translateY(branchLength/2 - 0.5);
                    
                    tree.add(branch);

                    // 3. Leaf Clusters attached to branches
                    const clustersPerBranch = 3;
                    for(let j=0; j<clustersPerBranch; j++) {
                        const size = 0.8 + Math.random();
                        const leafGeo = new THREE.DodecahedronGeometry(size, 0);
                        const mat = Math.random() > 0.5 ? leavesMat : leavesMatDark;
                        const leaf = new THREE.Mesh(leafGeo, mat);
                        
                        // Position along branch
                        const t = (j+1) / clustersPerBranch; // 0 to 1 along branch
                        leaf.position.copy(branch.position); // Start at branch center
                        
                        // Local offset logic is tricky without hierarchy, so we use simple offset
                        // Calculate approximate tip position based on rotation
                        const tipX = Math.sin(branch.rotation.y) * Math.sin(branch.rotation.z) * (branchLength * t);
                        const tipY = Math.cos(branch.rotation.z) * (branchLength * t);
                        const tipZ = Math.cos(branch.rotation.y) * Math.sin(branch.rotation.z) * (branchLength * t);

                        leaf.position.x += tipX + (Math.random()-0.5);
                        leaf.position.y += tipY + (Math.random()-0.5);
                        leaf.position.z += tipZ + (Math.random()-0.5);
                        
                        leaf.castShadow = true;
                        tree.add(leaf);
                    }
                }

                return tree;
            };

            // Place trees around the complex
            for (let i = 0; i < 25; i++) {
                const tree = treeGen();
                const angle = (i / 25) * Math.PI * 2;
                const radius = 20 + Math.random() * 15; // Distance from center
                
                tree.position.x = Math.cos(angle) * radius;
                tree.position.z = Math.sin(angle) * radius;
                
                // Variation
                tree.rotation.y = Math.random() * Math.PI;
                const scale = 0.9 + Math.random() * 0.4;
                tree.scale.setScalar(scale);

                scene.add(tree);
            }

            // Add some rocks near water
            const rockGeo = new THREE.DodecahedronGeometry(1, 0);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            for(let i=0; i<12; i++) {
                const rock = new THREE.Mesh(rockGeo, rockMat);
                const angle = Math.random() * Math.PI * 2;
                const r = 15 + Math.random() * 5;
                rock.position.set(Math.cos(angle)*r, 0.5, Math.sin(angle)*r);
                rock.scale.set(1.5 + Math.random(), 0.5 + Math.random()*0.5, 1.5+Math.random());
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        // --- Particle System (Sakura) ---

        function createSakuraTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Draw a simple petal shape
            ctx.fillStyle = '#ffb7c5';
            ctx.beginPath();
            ctx.ellipse(16, 16, 8, 14, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createSakuraParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = []; // Store random fall speeds
            
            for (let i = 0; i < CONFIG.particles; i++) {
                const x = (Math.random() - 0.5) * 80;
                const y = Math.random() * 50;
                const z = (Math.random() - 0.5) * 80;
                positions.push(x, y, z);
                
                velocities.push(
                    (Math.random() - 0.5) * 0.05, // x sway
                    -0.02 - Math.random() * 0.05, // y fall
                    (Math.random() - 0.5) * 0.05  // z sway
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const material = new THREE.PointsMaterial({
                color: CONFIG.colors.sakura,
                size: 0.4,
                map: createSakuraTexture(),
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function togglePetals() {
            windSpeed = windSpeed === 1.0 ? 5.0 : 1.0;
        }

        function updateParticles() {
            if (!particleSystem) return;

            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;

            for (let i = 0; i < CONFIG.particles; i++) {
                const i3 = i * 3;

                // Apply Velocity
                positions[i3] += velocities[i3] * windSpeed;     // X
                positions[i3 + 1] += velocities[i3 + 1];         // Y
                positions[i3 + 2] += velocities[i3 + 2] * windSpeed; // Z

                // Wind Swirl (using sine wave based on time and height)
                const time = clock.getElapsedTime();
                positions[i3] += Math.sin(time * 0.5 + positions[i3 + 1]) * 0.002 * windSpeed;

                // Reset if below water
                if (positions[i3 + 1] < 0) {
                    positions[i3 + 1] = 40 + Math.random() * 10; // Reset to top
                    positions[i3] = (Math.random() - 0.5) * 80;
                    positions[i3 + 2] = (Math.random() - 0.5) * 80;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateParticles();
            renderer.render(scene, camera);
        }

        // Initialize application
        init();

    </script>
</body>
</html>
